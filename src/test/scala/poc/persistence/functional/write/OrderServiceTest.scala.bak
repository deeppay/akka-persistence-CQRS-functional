package poc.persistence.functional
package write

import scalaz.\/, \/.{left, right}
import scalaz.{\/-, -\/} 
import scala.concurrent.{Future, ExecutionContext}

import scalaz.{Monad,MonadError}
import publish._
  
import Poc.{ProgramSync,ProgramAsync }

object WriteFunctional {
  
  //~ type ProgramSync[T] =  Error \/ T
  //~ type ProgramAsync[T] = Future[Error \/ T]
  
    
  
  //~ def flow[ P[_]: OrderService : PublishService: Monad] ( fromCommand : OrderCommand )
  def flow[ P[_] ] ( fromCommand : OrderCommand )
      ( implicit 
          OS: OrderService[P],
          PS : PublishService[P],
          M : Monad[P],
          E : MonadError[P,Error]
      ) 
      : P[OrderEvent] = {
    
    import OrderService.Syntax._ 
    import PublishService.Syntax._ 
    import scalaz.syntax.monadError._
    
      getLastEventAndValidate( fromCommand ) >>!
     ( lastEvent => saveCommand( fromCommand )( lastEvent.version )  ) >>!
     { newEvent  => 
        publish( newEvent ).ifM(
          newEvent.pure,
          (NoPublishEvent( newEvent ): Error).raiseError
        )
     }
    
    
    //~ for {
      //~ 
      //~ lastEvent <-  getLastEventAndValidate( fromCommand ) 
      //~ newEvent  <-  saveCommand( fromCommand )( lastEvent.version ) 
      //~ _ <- publish( newEvent ).ifM(
          //~ ().pure,
          //~ ( NoPublishEvent( newEvent ) : Error).raiseError
        //~ )
    //~ } yield( newEvent )
    
  } 
  
}

object Test {
  
  //~ import WriteFunctional._
  
  //~ import OrderServiceTestAsync._
  //~ import OrderServiceTestSync._
  //~ import PublishServiceTestSync._
  //~ 
  //~ val executeSyncOk    = flow[ ProgramSync ] ( InitOrder( "1", 0 ) )( new OrderServiceTestSync, new PublishServiceTestSync, OrderServiceTestSync.E)
  //~ val executeSyncOk    = flow[ ProgramSync ] ( InitOrder( "1", 0 ) )
  //~ val executeSyncNoOk  = flow[ ProgramSync ] ( CloseOrder( "1", 0 ) )
                                               //~ 
  //~ val executeAsyncOk   = flow[ ProgramAsync ]( InitOrder( "1", 0 ) )
  //~ val executeAsyncNoOk = flow[ ProgramAsync ]( CloseOrder( "1", 0 ) )
  
}
